<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: MDL_context Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classMDL__context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MDL_context Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="mdl_8h_source.html">mdl.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab0e1989a324f4a2918656245963f23fa"><td class="memItemLeft" align="right" valign="top"><a id="ab0e1989a324f4a2918656245963f23fa"></a>
typedef <a class="el" href="classI__P__List.html">I_P_List</a>&lt; <a class="el" href="classMDL__ticket.html">MDL_ticket</a>, <a class="el" href="structI__P__List__adapter.html">I_P_List_adapter</a>&lt; <a class="el" href="classMDL__ticket.html">MDL_ticket</a>, &amp;<a class="el" href="classMDL__ticket.html#a74155707577dfd12cc7f47229e4f0d17">MDL_ticket::next_in_context</a>, &amp;MDL_ticket::prev_in_context &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Ticket_list</b></td></tr>
<tr class="separator:ab0e1989a324f4a2918656245963f23fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c46960d79806f52abbf0ba43af6ad04"><td class="memItemLeft" align="right" valign="top"><a id="a0c46960d79806f52abbf0ba43af6ad04"></a>
typedef <a class="el" href="classI__P__List__iterator.html">Ticket_list::Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Ticket_iterator</b></td></tr>
<tr class="separator:a0c46960d79806f52abbf0ba43af6ad04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a21b35ef90597dcd411bf091acd1f4a38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a21b35ef90597dcd411bf091acd1f4a38">MDL_context</a> ()</td></tr>
<tr class="separator:a21b35ef90597dcd411bf091acd1f4a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01a1f42bd9ed050556c434fb6d007ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#af01a1f42bd9ed050556c434fb6d007ac">destroy</a> ()</td></tr>
<tr class="separator:af01a1f42bd9ed050556c434fb6d007ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d07a861aaf9db6fda46da196a8b0d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#ab6d07a861aaf9db6fda46da196a8b0d0">try_acquire_lock</a> (<a class="el" href="classMDL__request.html">MDL_request</a> *mdl_request)</td></tr>
<tr class="separator:ab6d07a861aaf9db6fda46da196a8b0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3702152de7ebdf6e2c54e5ba5cbecfda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a3702152de7ebdf6e2c54e5ba5cbecfda">acquire_lock</a> (<a class="el" href="classMDL__request.html">MDL_request</a> *mdl_request, ulong lock_wait_timeout)</td></tr>
<tr class="separator:a3702152de7ebdf6e2c54e5ba5cbecfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4583e611d097158c5f08b8d1133fbd7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a4583e611d097158c5f08b8d1133fbd7e">acquire_locks</a> (<a class="el" href="classI__P__List.html">MDL_request_list</a> *requests, ulong lock_wait_timeout)</td></tr>
<tr class="separator:a4583e611d097158c5f08b8d1133fbd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7108b456e7c5ee715ee6511c03d542"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a2a7108b456e7c5ee715ee6511c03d542">upgrade_shared_lock</a> (<a class="el" href="classMDL__ticket.html">MDL_ticket</a> *mdl_ticket, enum_mdl_type new_type, ulong lock_wait_timeout)</td></tr>
<tr class="separator:a2a7108b456e7c5ee715ee6511c03d542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ed5299b1da65397a7e6972425b5f2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a74ed5299b1da65397a7e6972425b5f2d">clone_ticket</a> (<a class="el" href="classMDL__request.html">MDL_request</a> *mdl_request)</td></tr>
<tr class="separator:a74ed5299b1da65397a7e6972425b5f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bd65389a74778433291eb2d426c71f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a73bd65389a74778433291eb2d426c71f">release_all_locks_for_name</a> (<a class="el" href="classMDL__ticket.html">MDL_ticket</a> *ticket)</td></tr>
<tr class="separator:a73bd65389a74778433291eb2d426c71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71874a5e485217650429849ab29ed43b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a71874a5e485217650429849ab29ed43b">release_locks</a> (<a class="el" href="classMDL__release__locks__visitor.html">MDL_release_locks_visitor</a> *visitor)</td></tr>
<tr class="separator:a71874a5e485217650429849ab29ed43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d0df5eb422cbfa9a4225218c76141f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a58d0df5eb422cbfa9a4225218c76141f">release_lock</a> (<a class="el" href="classMDL__ticket.html">MDL_ticket</a> *ticket)</td></tr>
<tr class="separator:a58d0df5eb422cbfa9a4225218c76141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffac048f9ce71eb3a5e3b1a38178fdc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#adffac048f9ce71eb3a5e3b1a38178fdc">owns_equal_or_stronger_lock</a> (<a class="el" href="structMDL__key.html#a391ec4bd98fec6852a48f7856546ed3b">MDL_key::enum_mdl_namespace</a> mdl_namespace, const char *db, const char *name, enum_mdl_type mdl_type)</td></tr>
<tr class="separator:adffac048f9ce71eb3a5e3b1a38178fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf6eddf26617c84f0c2c21af8ec4a94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a7cf6eddf26617c84f0c2c21af8ec4a94">find_lock_owner</a> (const <a class="el" href="structMDL__key.html">MDL_key</a> *mdl_key, <a class="el" href="classMDL__context__visitor.html">MDL_context_visitor</a> *visitor)</td></tr>
<tr class="separator:a7cf6eddf26617c84f0c2c21af8ec4a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc9db02d0a60b144fd35770424ba1ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#adfc9db02d0a60b144fd35770424ba1ae">has_lock</a> (const <a class="el" href="classMDL__savepoint.html">MDL_savepoint</a> &amp;mdl_savepoint, <a class="el" href="classMDL__ticket.html">MDL_ticket</a> *mdl_ticket)</td></tr>
<tr class="separator:adfc9db02d0a60b144fd35770424ba1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36680261ff26d6eb9ea19e2a290294d"><td class="memItemLeft" align="right" valign="top"><a id="ae36680261ff26d6eb9ea19e2a290294d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_locks</b> () const</td></tr>
<tr class="separator:ae36680261ff26d6eb9ea19e2a290294d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff2d2559c4ef5075b63978ae516df6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a3ff2d2559c4ef5075b63978ae516df6e">has_locks</a> (<a class="el" href="structMDL__key.html#a391ec4bd98fec6852a48f7856546ed3b">MDL_key::enum_mdl_namespace</a> mdl_namespace) const</td></tr>
<tr class="separator:a3ff2d2559c4ef5075b63978ae516df6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77b38a67ffb56d071a98efc8879bac6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#ab77b38a67ffb56d071a98efc8879bac6">has_locks_waited_for</a> () const</td></tr>
<tr class="separator:ab77b38a67ffb56d071a98efc8879bac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213edf20be43313e0346a489c2f47dd6"><td class="memItemLeft" align="right" valign="top"><a id="a213edf20be43313e0346a489c2f47dd6"></a>
<a class="el" href="classMDL__savepoint.html">MDL_savepoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mdl_savepoint</b> ()</td></tr>
<tr class="separator:a213edf20be43313e0346a489c2f47dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357599f5af7c6ec7587ecb7b349f0313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a357599f5af7c6ec7587ecb7b349f0313">set_explicit_duration_for_all_locks</a> ()</td></tr>
<tr class="separator:a357599f5af7c6ec7587ecb7b349f0313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b07243d69f1354e3bb5936dd6ded15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#ad1b07243d69f1354e3bb5936dd6ded15">set_transaction_duration_for_all_locks</a> ()</td></tr>
<tr class="separator:ad1b07243d69f1354e3bb5936dd6ded15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5836b7c79f957c575c90ad4f1d8296de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a5836b7c79f957c575c90ad4f1d8296de">set_lock_duration</a> (<a class="el" href="classMDL__ticket.html">MDL_ticket</a> *mdl_ticket, enum_mdl_duration duration)</td></tr>
<tr class="separator:a5836b7c79f957c575c90ad4f1d8296de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55150d0bbe77cf0cd38e7005a4330e44"><td class="memItemLeft" align="right" valign="top"><a id="a55150d0bbe77cf0cd38e7005a4330e44"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>release_statement_locks</b> ()</td></tr>
<tr class="separator:a55150d0bbe77cf0cd38e7005a4330e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce65a72bedc0c4384b2b4c231c070ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#afce65a72bedc0c4384b2b4c231c070ed">release_transactional_locks</a> ()</td></tr>
<tr class="separator:afce65a72bedc0c4384b2b4c231c070ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863ff94d0928e9720df30643835e4ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a863ff94d0928e9720df30643835e4ef0">rollback_to_savepoint</a> (const <a class="el" href="classMDL__savepoint.html">MDL_savepoint</a> &amp;mdl_savepoint)</td></tr>
<tr class="separator:a863ff94d0928e9720df30643835e4ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa476fbd9d7d0352352d551279e853314"><td class="memItemLeft" align="right" valign="top"><a id="aa476fbd9d7d0352352d551279e853314"></a>
<a class="el" href="classMDL__context__owner.html">MDL_context_owner</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_owner</b> () const</td></tr>
<tr class="separator:aa476fbd9d7d0352352d551279e853314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3563d6d05aeb758f495f44c123c5306b"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a3563d6d05aeb758f495f44c123c5306b">get_deadlock_weight</a> () const</td></tr>
<tr class="separator:a3563d6d05aeb758f495f44c123c5306b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c29aa7919001edcdfaa82bc360c65df"><td class="memItemLeft" align="right" valign="top"><a id="a4c29aa7919001edcdfaa82bc360c65df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (<a class="el" href="classMDL__context__owner.html">MDL_context_owner</a> *arg)</td></tr>
<tr class="separator:a4c29aa7919001edcdfaa82bc360c65df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74608d443dfc4754ce1b14c672a914f1"><td class="memItemLeft" align="right" valign="top"><a id="a74608d443dfc4754ce1b14c672a914f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_needs_thr_lock_abort</b> (bool needs_thr_lock_abort)</td></tr>
<tr class="separator:a74608d443dfc4754ce1b14c672a914f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc1ba94d5bbd550b7e1d0ab88882060"><td class="memItemLeft" align="right" valign="top"><a id="adbc1ba94d5bbd550b7e1d0ab88882060"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_needs_thr_lock_abort</b> () const</td></tr>
<tr class="separator:adbc1ba94d5bbd550b7e1d0ab88882060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39728ceab1f092a3bf1e8a4ec168f9bb"><td class="memItemLeft" align="right" valign="top"><a id="a39728ceab1f092a3bf1e8a4ec168f9bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_force_dml_deadlock_weight</b> (bool force_dml_deadlock_weight)</td></tr>
<tr class="separator:a39728ceab1f092a3bf1e8a4ec168f9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6023ebdf937cfcbf9991b10945ad952f"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a6023ebdf937cfcbf9991b10945ad952f">get_random</a> ()</td></tr>
<tr class="separator:a6023ebdf937cfcbf9991b10945ad952f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2260019c16977e8ed6aba3081f16348f"><td class="memItemLeft" align="right" valign="top">THD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#a2260019c16977e8ed6aba3081f16348f">get_thd</a> () const</td></tr>
<tr class="separator:a2260019c16977e8ed6aba3081f16348f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e75a7f44e5bc687620aff289a00f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#aa0e75a7f44e5bc687620aff289a00f52">find_deadlock</a> ()</td></tr>
<tr class="separator:aa0e75a7f44e5bc687620aff289a00f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab778763f11b187ab171213c9fa08846e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#ab778763f11b187ab171213c9fa08846e">visit_subgraph</a> (<a class="el" href="classMDL__wait__for__graph__visitor.html">MDL_wait_for_graph_visitor</a> *dvisitor)</td></tr>
<tr class="separator:ab778763f11b187ab171213c9fa08846e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd74a4227cf8ddea993d96ee3be25331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#afd74a4227cf8ddea993d96ee3be25331">will_wait_for</a> (<a class="el" href="classMDL__wait__for__subgraph.html">MDL_wait_for_subgraph</a> *waiting_for_arg)</td></tr>
<tr class="separator:afd74a4227cf8ddea993d96ee3be25331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d3fb033110d449d894c95f33f6d9b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#ad5d3fb033110d449d894c95f33f6d9b1">done_waiting_for</a> ()</td></tr>
<tr class="separator:ad5d3fb033110d449d894c95f33f6d9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca0ec235888a94af4dd25107a8af389"><td class="memItemLeft" align="right" valign="top"><a id="aaca0ec235888a94af4dd25107a8af389"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>lock_deadlock_victim</b> ()</td></tr>
<tr class="separator:aaca0ec235888a94af4dd25107a8af389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a0ef8ba360e3d48885f711723aa3ea"><td class="memItemLeft" align="right" valign="top"><a id="af3a0ef8ba360e3d48885f711723aa3ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock_deadlock_victim</b> ()</td></tr>
<tr class="separator:af3a0ef8ba360e3d48885f711723aa3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aeaf51be6c5480bb1e718aea933f55d9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMDL__wait.html">MDL_wait</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__context.html#aeaf51be6c5480bb1e718aea933f55d9d">m_wait</a></td></tr>
<tr class="separator:aeaf51be6c5480bb1e718aea933f55d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p class="">Context of the owner of metadata locks. I.e. each server connection has such a context. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a21b35ef90597dcd411bf091acd1f4a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b35ef90597dcd411bf091acd1f4a38">&#9670;&nbsp;</a></span>MDL_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MDL_context::MDL_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Initialize a metadata locking context.</p>
<p class="">This is to be called when a new server connection is created. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3702152de7ebdf6e2c54e5ba5cbecfda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3702152de7ebdf6e2c54e5ba5cbecfda">&#9670;&nbsp;</a></span>acquire_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::acquire_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__request.html">MDL_request</a> *&#160;</td>
          <td class="paramname"><em>mdl_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>lock_wait_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Acquire one lock with waiting for conflicting locks to go away if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdl_request</td><td>[in/out] Lock request object for lock to be acquired</td></tr>
    <tr><td class="paramname">lock_wait_timeout</td><td>[in] Seconds to wait before timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. <a class="el" href="classMDL__request.html#a99421002fe2ea1580766846c0ef339ae">MDL_request::ticket</a> points to the ticket for the lock. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (Out of resources or waiting is aborted), </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4583e611d097158c5f08b8d1133fbd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4583e611d097158c5f08b8d1133fbd7e">&#9670;&nbsp;</a></span>acquire_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::acquire_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classI__P__List.html">MDL_request_list</a> *&#160;</td>
          <td class="paramname"><em>mdl_requests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>lock_wait_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Acquire exclusive locks. There must be no granted locks in the context.</p>
<p class="">This is a replacement of <a class="el" href="group__Data__Dictionary.html#gae06de7ce22001b035ca61edf2a3dea09">lock_table_names()</a>. It is used in RENAME, DROP and other DDL SQL statements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdl_requests</td><td><a class="el" href="classList.html">List</a> of requests for locks to be acquired.</td></tr>
    <tr><td class="paramname">lock_wait_timeout</td><td>Seconds to wait before timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The list of requests should not contain non-exclusive lock requests. There should not be any acquired locks in the context.</dd>
<dd>
Assumes that one already owns scoped intention exclusive lock.</dd>
<dd>
If acquisition fails any locks with MDL_EXPLICIT duration that had already been taken, are released. Not just locks with MDL_STATEMENT and MDL_TRANSACTION duration. This makes acquition of MDL_EXPLICIT locks atomic (all or nothing). This is needed for the locking service plugin API.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74ed5299b1da65397a7e6972425b5f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ed5299b1da65397a7e6972425b5f2d">&#9670;&nbsp;</a></span>clone_ticket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::clone_ticket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__request.html">MDL_request</a> *&#160;</td>
          <td class="paramname"><em>mdl_request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Create a copy of a granted ticket. This is used to make sure that HANDLER ticket is never shared with a ticket that belongs to a transaction, so that when we HANDLER CLOSE, we don't release a transactional ticket, and vice versa &ndash; when we COMMIT, we don't mistakenly release a ticket for an open HANDLER.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Out of memory. </td></tr>
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af01a1f42bd9ed050556c434fb6d007ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01a1f42bd9ed050556c434fb6d007ac">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::destroy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Destroy metadata locking context.</p>
<p class="">Assumes and asserts that there are no active or pending locks associated with this context at the time of the destruction.</p>
<p class="">Currently does nothing. Asserts that there are no pending or satisfied lock requests. The pending locks must be released prior to destruction. This is a new way to express the assertion that all tables are closed before a connection is destroyed. </p>

</div>
</div>
<a id="ad5d3fb033110d449d894c95f33f6d9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d3fb033110d449d894c95f33f6d9b1">&#9670;&nbsp;</a></span>done_waiting_for()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::done_waiting_for </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Remove the wait-for edge from the graph after we're done waiting. </p>

</div>
</div>
<a id="aa0e75a7f44e5bc687620aff289a00f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e75a7f44e5bc687620aff289a00f52">&#9670;&nbsp;</a></span>find_deadlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::find_deadlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Try to find a deadlock. This function produces no errors.</p>
<dl class="section note"><dt>Note</dt><dd>If during deadlock resolution context which performs deadlock detection is chosen as a victim it will be informed about the fact by setting VICTIM status to its wait slot. </dd></dl>

</div>
</div>
<a id="a7cf6eddf26617c84f0c2c21af8ec4a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf6eddf26617c84f0c2c21af8ec4a94">&#9670;&nbsp;</a></span>find_lock_owner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::find_lock_owner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMDL__key.html">MDL_key</a> *&#160;</td>
          <td class="paramname"><em>mdl_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__context__visitor.html">MDL_context_visitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find the first context which owns the lock and inspect it by calling MDL_context_visitor::visit_context() method.</p>
<dl class="section return"><dt>Returns</dt><dd>True in case error (e.g. OOM). False otherwise. There is no guarantee that owner was found in either case. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method only works properly for locks which were acquired using "slow" path. </dd></dl>

</div>
</div>
<a id="a3563d6d05aeb758f495f44c123c5306b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3563d6d05aeb758f495f44c123c5306b">&#9670;&nbsp;</a></span>get_deadlock_weight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint MDL_context::get_deadlock_weight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section pre"><dt>Precondition</dt><dd>Only valid if we started waiting for lock. </dd></dl>

</div>
</div>
<a id="a6023ebdf937cfcbf9991b10945ad952f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6023ebdf937cfcbf9991b10945ad952f">&#9670;&nbsp;</a></span>get_random()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint MDL_context::get_random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get pseudo random value in [0 .. 2^31-1] range.</p>
<dl class="section note"><dt>Note</dt><dd>We use Linear Congruential Generator with venerable constant parameters for this. It is known to have problems with its lower bits are not being very random so probably is not good enough for generic use. However, we only use it to do random dives into <a class="el" href="classMDL__lock.html">MDL_lock</a> objects hash when searching for unused objects to be freed, and for this purposes it is sufficient. We rely on values of "get_random() % 2^k" expression having "2^k" as a period to ensure that random dives eventually cover all hash (the former can be proven to be true). This also means that there is no bias towards any specific objects to be expelled (as hash values don't repeat), which is nice for performance. </dd></dl>

</div>
</div>
<a id="a2260019c16977e8ed6aba3081f16348f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2260019c16977e8ed6aba3081f16348f">&#9670;&nbsp;</a></span>get_thd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">THD* MDL_context::get_thd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Within MDL subsystem this one is only used for DEBUG_SYNC. Do not use it to peek/poke into other parts of THD from MDL. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classMDL__context__owner.html#a6e93b957e332a9811d4a2d4195bd3e21">MDL_context_owner::get_thd()</a>. </dd></dl>

</div>
</div>
<a id="adfc9db02d0a60b144fd35770424ba1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc9db02d0a60b144fd35770424ba1ae">&#9670;&nbsp;</a></span>has_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::has_lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMDL__savepoint.html">MDL_savepoint</a> &amp;&#160;</td>
          <td class="paramname"><em>mdl_savepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>mdl_ticket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Does this savepoint have this lock?</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>The ticket is older than the savepoint or is an LT, HA or GLR ticket. Thus it belongs to the savepoint or has explicit duration. </td></tr>
    <tr><td class="paramname">FALSE</td><td>The ticket is newer than the savepoint. and is not an LT, HA or GLR ticket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ff2d2559c4ef5075b63978ae516df6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff2d2559c4ef5075b63978ae516df6e">&#9670;&nbsp;</a></span>has_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::has_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMDL__key.html#a391ec4bd98fec6852a48f7856546ed3b">MDL_key::enum_mdl_namespace</a>&#160;</td>
          <td class="paramname"><em>mdl_namespace</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Does this context have an lock of the given namespace?</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>At least one lock of given namespace held </td></tr>
    <tr><td class="paramname">false</td><td>No locks of the given namespace held </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab77b38a67ffb56d071a98efc8879bac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77b38a67ffb56d071a98efc8879bac6">&#9670;&nbsp;</a></span>has_locks_waited_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::has_locks_waited_for </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Do we hold any locks which are possibly being waited for by another <a class="el" href="classMDL__context.html">MDL_context</a>?</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>A lock being 'waited_for' was found. </td></tr>
    <tr><td class="paramname">FALSE</td><td>No one waits for the lock(s) we hold.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Should only be called from the thread which owns the <a class="el" href="classMDL__context.html">MDL_context</a> </dd></dl>

</div>
</div>
<a id="adffac048f9ce71eb3a5e3b1a38178fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffac048f9ce71eb3a5e3b1a38178fdc">&#9670;&nbsp;</a></span>owns_equal_or_stronger_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::owns_equal_or_stronger_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMDL__key.html#a391ec4bd98fec6852a48f7856546ed3b">MDL_key::enum_mdl_namespace</a>&#160;</td>
          <td class="paramname"><em>mdl_namespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_mdl_type&#160;</td>
          <td class="paramname"><em>mdl_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Auxiliary function which allows to check if we have some kind of lock on a object. Returns TRUE if we have a lock of an equal to given or stronger type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdl_namespace</td><td>Id of object namespace </td></tr>
    <tr><td class="paramname">db</td><td>Name of the database </td></tr>
    <tr><td class="paramname">name</td><td>Name of the object </td></tr>
    <tr><td class="paramname">mdl_type</td><td>Lock type. Pass in the weakest type to find out if there is at least some lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if current context contains satisfied lock for the object, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a73bd65389a74778433291eb2d426c71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bd65389a74778433291eb2d426c71f">&#9670;&nbsp;</a></span>release_all_locks_for_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::release_all_locks_for_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Release all explicit locks in the context which correspond to the same name/object as this lock request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>One of the locks for the name/object for which all locks should be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58d0df5eb422cbfa9a4225218c76141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d0df5eb422cbfa9a4225218c76141f">&#9670;&nbsp;</a></span>release_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::release_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>ticket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Release lock with explicit duration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticket</td><td>Ticket for lock to be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71874a5e485217650429849ab29ed43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71874a5e485217650429849ab29ed43b">&#9670;&nbsp;</a></span>release_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::release_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__release__locks__visitor.html">MDL_release_locks_visitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Release all explicit locks in the context for which the release() method of the provided visitor evalates to true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>Object to ask if the lock should be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afce65a72bedc0c4384b2b4c231c070ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce65a72bedc0c4384b2b4c231c070ed">&#9670;&nbsp;</a></span>release_transactional_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::release_transactional_locks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Release locks acquired by normal statements (SELECT, UPDATE, DELETE, etc) in the course of a transaction. Do not release HANDLER locks, if there are any.</p>
<p class="">This method is used at the end of a transaction, in implementation of COMMIT (implicit or explicit) and ROLLBACK. </p>

</div>
</div>
<a id="a863ff94d0928e9720df30643835e4ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863ff94d0928e9720df30643835e4ef0">&#9670;&nbsp;</a></span>rollback_to_savepoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::rollback_to_savepoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMDL__savepoint.html">MDL_savepoint</a> &amp;&#160;</td>
          <td class="paramname"><em>mdl_savepoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Releases metadata locks that were acquired after a specific savepoint.</p>
<dl class="section note"><dt>Note</dt><dd>Used to release tickets acquired during a savepoint unit. </dd>
<dd>
It's safe to iterate and unlock any locks after taken after this savepoint because other statements that take other special locks cause a implicit commit (ie LOCK TABLES). </dd></dl>

</div>
</div>
<a id="a357599f5af7c6ec7587ecb7b349f0313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357599f5af7c6ec7587ecb7b349f0313">&#9670;&nbsp;</a></span>set_explicit_duration_for_all_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::set_explicit_duration_for_all_locks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Set explicit duration for all locks in the context. </p>

</div>
</div>
<a id="a5836b7c79f957c575c90ad4f1d8296de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5836b7c79f957c575c90ad4f1d8296de">&#9670;&nbsp;</a></span>set_lock_duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::set_lock_duration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>mdl_ticket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_mdl_duration&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Change lock duration for transactional lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticket</td><td>Ticket representing lock. </td></tr>
    <tr><td class="paramname">duration</td><td>Lock duration to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method only supports changing duration of transactional lock to some other duration. </dd></dl>

</div>
</div>
<a id="ad1b07243d69f1354e3bb5936dd6ded15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b07243d69f1354e3bb5936dd6ded15">&#9670;&nbsp;</a></span>set_transaction_duration_for_all_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::set_transaction_duration_for_all_locks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Set transactional duration for all locks in the context. </p>

</div>
</div>
<a id="ab6d07a861aaf9db6fda46da196a8b0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d07a861aaf9db6fda46da196a8b0d0">&#9670;&nbsp;</a></span>try_acquire_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::try_acquire_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__request.html">MDL_request</a> *&#160;</td>
          <td class="paramname"><em>mdl_request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Try to acquire one lock.</p>
<p class="">Unlike exclusive locks, shared locks are acquired one by one. This is interface is chosen to simplify introduction of the new locking API to the system. <a class="el" href="classMDL__context.html#ab6d07a861aaf9db6fda46da196a8b0d0">MDL_context::try_acquire_lock()</a> is currently used from <a class="el" href="group__Data__Dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a>, and there we have only one table to work with.</p>
<p class="">This function may also be used to try to acquire an exclusive lock on a destination table, by ALTER <a class="el" href="structTABLE.html">TABLE</a> ... RENAME.</p>
<p class="">Returns immediately without any side effect if encounters a lock conflict. Otherwise takes the lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdl_request</td><td>[in/out] Lock request object for lock to be acquired</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. The lock may have not been acquired. Check the ticket, if it's NULL, a conflicting lock exists. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Out of resources, an error has been reported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a7108b456e7c5ee715ee6511c03d542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7108b456e7c5ee715ee6511c03d542">&#9670;&nbsp;</a></span>upgrade_shared_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::upgrade_shared_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>mdl_ticket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_mdl_type&#160;</td>
          <td class="paramname"><em>new_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>lock_wait_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Upgrade a shared metadata lock.</p>
<p class="">Used in ALTER <a class="el" href="structTABLE.html">TABLE</a> and CREATE <a class="el" href="structTABLE.html">TABLE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdl_ticket</td><td>Lock to upgrade. </td></tr>
    <tr><td class="paramname">new_type</td><td>Lock type to upgrade to. </td></tr>
    <tr><td class="paramname">lock_wait_timeout</td><td>Seconds to wait before timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In case of failure to upgrade lock (e.g. because upgrader was killed) leaves lock in its original state (locked in shared mode).</dd>
<dd>
There can be only one upgrader for a lock or we will have deadlock. This invariant is ensured by the fact that upgradeable locks SU, SNW and SNRW are not compatible with each other and themselves in case of ALTER <a class="el" href="structTABLE.html">TABLE</a> operation. In case of CREATE <a class="el" href="structTABLE.html">TABLE</a> operation there is chance of deadlock as 'S' is compatible with 'S'. But the deadlock is recovered by backoff and retry mechanism.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (thread was killed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab778763f11b187ab171213c9fa08846e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab778763f11b187ab171213c9fa08846e">&#9670;&nbsp;</a></span>visit_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::visit_subgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__wait__for__graph__visitor.html">MDL_wait_for_graph_visitor</a> *&#160;</td>
          <td class="paramname"><em>gvisitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">A fragment of recursive traversal of the wait-for graph of MDL contexts in the server in search for deadlocks. Assume this MDL context is a node in the wait-for graph, and direct the visitor to all adjacent nodes. As long as the starting node is remembered in the visitor, a deadlock is found when the same node is visited twice. One MDL context is connected to another in the wait-for graph if it waits on a resource that is held by the other context.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>A deadlock is found. A pointer to deadlock victim is saved in the visitor. </td></tr>
    <tr><td class="paramname">FALSE</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd74a4227cf8ddea993d96ee3be25331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd74a4227cf8ddea993d96ee3be25331">&#9670;&nbsp;</a></span>will_wait_for()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::will_wait_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__wait__for__subgraph.html">MDL_wait_for_subgraph</a> *&#160;</td>
          <td class="paramname"><em>waiting_for_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Inform the deadlock detector there is an edge in the wait-for graph. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aeaf51be6c5480bb1e718aea933f55d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf51be6c5480bb1e718aea933f55d9d">&#9670;&nbsp;</a></span>m_wait</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMDL__wait.html">MDL_wait</a> MDL_context::m_wait</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">If our request for a lock is scheduled, or aborted by the deadlock detector, the result is recorded in this class. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="mdl_8h_source.html">mdl.h</a></li>
<li>mdl.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
